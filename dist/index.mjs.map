{"version":3,"file":"index.mjs","names":["allowPredicate: (obj: any) => boolean","seen: any[]","parts: string[]","state: State<T>","waiting: Array<{\r\n    resolve: (value: T) => void;\r\n    reject: (err: unknown) => void;\r\n  }>","next: T","emptyInstance: Instance<any>","init: (\r\n      arg: {\r\n        emit: Waitable<T>[\"emit\"];\r\n        retain: Instance<T>[\"retain\"];\r\n        key: string;\r\n      },\r\n      ctx: ContextArgs<C>\r\n    ) => Promise<void> | void","config?: ResourceConfig<T>","resolveClose!: () => void","resolveRetain!: () => void","resolveFinish!: () => void","instance: Instance<T>"],"sources":["../src/lib/stringify.ts","../src/lib/waitable.ts","../src/resource.ts","../src/action.ts"],"sourcesContent":["import { createHash } from \"crypto\";\r\n\r\nclass ReferenceRegistry {\r\n  private refCount = 0;\r\n  private refs = new WeakMap<object, string>();\r\n\r\n  constructor(private allowPredicate: (obj: any) => boolean) {}\r\n\r\n  getId(obj: any): string | undefined {\r\n    if (!this.allowPredicate(obj)) return undefined;\r\n\r\n    if (!this.refs.has(obj)) {\r\n      this.refCount++;\r\n      this.refs.set(obj, `__ref_${this.refCount}__`);\r\n    }\r\n\r\n    return this.refs.get(obj);\r\n  }\r\n}\r\n\r\nconst registry = new ReferenceRegistry((obj) => {\r\n  return (\r\n    typeof obj === \"function\" ||\r\n    (obj && typeof obj === \"object\" && obj.constructor !== Object) ||\r\n    typeof obj === \"symbol\"\r\n  );\r\n});\r\n\r\nfunction stableStringify(data: any): string {\r\n  const seen: any[] = [];\r\n\r\n  function stringifyInternal(node: any): string | undefined {\r\n    if (node && typeof node.toJSON === \"function\") {\r\n      node = node.toJSON();\r\n    }\r\n\r\n    if (registry && node && typeof node === \"object\") {\r\n      const refId = registry.getId(node);\r\n      if (refId) return JSON.stringify(refId);\r\n    }\r\n\r\n    if (typeof node === \"function\") {\r\n      const refId = registry.getId(node);\r\n      if (refId) return JSON.stringify(refId);\r\n      return undefined;\r\n    }\r\n\r\n    if (typeof node === \"bigint\") return `\"${node.toString()}n\"`;\r\n    if (node === undefined) return undefined;\r\n\r\n    if (typeof node !== \"object\" || node === null) {\r\n      if (typeof node === \"number\" && !Number.isFinite(node)) return \"null\";\r\n      return JSON.stringify(node);\r\n    }\r\n\r\n    if (Array.isArray(node)) {\r\n      const out = node.map((v) => stringifyInternal(v) ?? \"null\").join(\",\");\r\n      return `[${out}]`;\r\n    }\r\n\r\n    if (seen.includes(node)) return JSON.stringify(\"__cycle__\");\r\n\r\n    if (node instanceof Date) return `\"${node.toISOString()}\"`;\r\n    if (node instanceof RegExp) return JSON.stringify(node.toString());\r\n\r\n    if (node instanceof Map) {\r\n      const sorted = Array.from(node.entries()).sort((a, b) =>\r\n        String(a[0]).localeCompare(String(b[0]))\r\n      );\r\n      const out = sorted\r\n        .map(([k, v]) => `[${stringifyInternal(k)},${stringifyInternal(v)}]`)\r\n        .join(\",\");\r\n      return `[${out}]`;\r\n    }\r\n\r\n    if (node instanceof Set) {\r\n      const sorted = Array.from(node.values()).sort((a, b) =>\r\n        String(a).localeCompare(String(b))\r\n      );\r\n      const out = sorted.map((v) => stringifyInternal(v)).join(\",\");\r\n      return `[${out}]`;\r\n    }\r\n\r\n    seen.push(node);\r\n    const keys = Object.keys(node).sort();\r\n    const parts: string[] = [];\r\n    for (const key of keys) {\r\n      const val = stringifyInternal(node[key]);\r\n      if (val !== undefined) parts.push(`${JSON.stringify(key)}:${val}`);\r\n    }\r\n    seen.pop();\r\n\r\n    return `{${parts.join(\",\")}}`;\r\n  }\r\n\r\n  return stringifyInternal(data) || \"null\";\r\n}\r\n\r\nexport function stableHash(data: any): string {\r\n  const json = stableStringify(data);\r\n  const hash = createHash(\"sha256\").update(json).digest(\"hex\");\r\n  return hash;\r\n}\r\n","export type Waitable<T> = {\r\n  emit: (value: T | Promise<T> | ((prev?: T) => T | Promise<T>)) => void;\r\n  throw: (error: unknown) => void;\r\n  get: () => Promise<T>;\r\n};\r\n\r\ntype WaitableOptions<T> = {\r\n  shouldAccept?: (next: T, prev?: T) => boolean;\r\n  afterEmit?: (next: T, prev?: T) => void;\r\n  afterThrow?: (error: unknown) => void;\r\n  equality?: (a: T, b: T) => boolean;\r\n};\r\n\r\ntype State<T> =\r\n  | { status: \"pending\" }\r\n  | { status: \"resolved\"; value: T }\r\n  | { status: \"rejected\"; error: unknown };\r\n\r\nexport function createWaitable<T>(\r\n  options: WaitableOptions<T> = {}\r\n): Waitable<T> {\r\n  let state: State<T> = { status: \"pending\" };\r\n\r\n  let waiting: Array<{\r\n    resolve: (value: T) => void;\r\n    reject: (err: unknown) => void;\r\n  }> = [];\r\n\r\n  function flush() {\r\n    const queued = waiting;\r\n    waiting = [];\r\n\r\n    if (state.status === \"resolved\") {\r\n      for (const { resolve } of queued) resolve(state.value);\r\n    } else if (state.status === \"rejected\") {\r\n      for (const { reject } of queued) reject(state.error);\r\n    }\r\n  }\r\n\r\n  async function emit(input: T | Promise<T> | ((prev?: T) => T | Promise<T>)) {\r\n    const prev = state.status === \"resolved\" ? state.value : undefined;\r\n\r\n    let next: T;\r\n    try {\r\n      if (typeof input === \"function\") {\r\n        const fn = input as (prev?: T) => T | Promise<T>;\r\n        next = await fn(prev);\r\n      } else {\r\n        next = await input;\r\n      }\r\n    } catch (err) {\r\n      _throw(err);\r\n      return;\r\n    }\r\n\r\n    const equals = options.equality ?? (() => false);\r\n\r\n    if (state.status === \"resolved\" && equals(next, state.value)) return;\r\n\r\n    if (options.shouldAccept && !options.shouldAccept(next, prev)) {\r\n      return;\r\n    }\r\n\r\n    state = { status: \"resolved\", value: next };\r\n\r\n    flush();\r\n\r\n    if (options.afterEmit) {\r\n      queueMicrotask(() => options.afterEmit!(next, prev));\r\n    }\r\n  }\r\n\r\n  function _throw(error: unknown) {\r\n    state = { status: \"rejected\", error };\r\n\r\n    flush();\r\n\r\n    if (options.afterThrow) {\r\n      queueMicrotask(() => options.afterThrow!(error));\r\n    }\r\n  }\r\n\r\n  function get(): Promise<T> {\r\n    if (state.status === \"resolved\") {\r\n      return Promise.resolve(state.value);\r\n    }\r\n    if (state.status === \"rejected\") {\r\n      return Promise.reject(state.error);\r\n    }\r\n    return new Promise<T>((resolve, reject) => {\r\n      waiting.push({ resolve, reject });\r\n    });\r\n  }\r\n\r\n  return { emit, throw: _throw, get };\r\n}\r\n","import { stableHash } from \"./lib/stringify\";\r\nimport { createWaitable, Waitable } from \"./lib/waitable\";\r\n\r\nexport type RefLike<T> = {\r\n  readonly key: string;\r\n  readonly value: Promise<T>;\r\n  onEmit: (fn: ValueSubscriber<T>) => () => boolean;\r\n  onError: (fn: ErrorSubscriber) => () => boolean;\r\n};\r\n\r\ntype GlobalValueSubscriber<T, C> = (\r\n  value: T,\r\n  prev: T | undefined,\r\n  ctx: ContextArgs<C>,\r\n  key: string\r\n) => void;\r\n\r\ntype GlobalErrorSubscriber<C> = (\r\n  error: unknown,\r\n  ctx: ContextArgs<C>,\r\n  key: string\r\n) => void;\r\n\r\ntype ContextArgs<C> = keyof C extends never ? void : C;\r\n\r\ntype ValueSubscriber<T> = (value: T, prev?: T) => void;\r\ntype ErrorSubscriber = (error: unknown) => void;\r\n\r\ntype ResourceConfig<T> = {\r\n  name?: string;\r\n  equality?: (a: T, b: T) => boolean;\r\n};\r\n\r\ntype Instance<T> = {\r\n  key: string;\r\n  refs: Map<\r\n    symbol,\r\n    { notifyEmit: ValueSubscriber<T>; notifyError: ErrorSubscriber }\r\n  >;\r\n  running: boolean;\r\n  get: () => Promise<T>;\r\n  close: () => void;\r\n  retain: () => Promise<void>;\r\n  untilClose: Promise<void>;\r\n  untilRetain: Promise<void>;\r\n  untilFinish: Promise<void>;\r\n};\r\n\r\nconst emptyInstance: Instance<any> = {\r\n  key: \"\",\r\n  refs: new Map(),\r\n  running: false,\r\n  get: async () => {\r\n    throw new Error(\"Called get on empty Resource ref\");\r\n  },\r\n  close: () => {},\r\n  retain: async () => {},\r\n  untilClose: Promise.resolve(),\r\n  untilRetain: Promise.resolve(),\r\n  untilFinish: Promise.resolve(),\r\n};\r\n\r\nexport class Resource<T, C = {}> {\r\n  private globalEmitSubs = new Set<GlobalValueSubscriber<T, C>>();\r\n  private globalErrorSubs = new Set<GlobalErrorSubscriber<C>>();\r\n  private instances = new Map<string, Instance<T>>();\r\n\r\n  constructor(\r\n    private init: (\r\n      arg: {\r\n        emit: Waitable<T>[\"emit\"];\r\n        retain: Instance<T>[\"retain\"];\r\n        key: string;\r\n      },\r\n      ctx: ContextArgs<C>\r\n    ) => Promise<void> | void,\r\n    private config?: ResourceConfig<T>\r\n  ) {}\r\n\r\n  get name() {\r\n    return this.config?.name;\r\n  }\r\n\r\n  use(ctx: ContextArgs<C>) {\r\n    const instance = this.prepareInstance(ctx);\r\n    return this.createRef({ instance });\r\n  }\r\n\r\n  empty() {\r\n    return this.createRef({ instance: emptyInstance });\r\n  }\r\n\r\n  onEveryEmit(fn: GlobalValueSubscriber<T, C>) {\r\n    this.globalEmitSubs.add(fn);\r\n    return () => {\r\n      this.globalEmitSubs.delete(fn);\r\n    };\r\n  }\r\n\r\n  onEveryError(fn: GlobalErrorSubscriber<C>) {\r\n    this.globalErrorSubs.add(fn);\r\n    return () => {\r\n      this.globalErrorSubs.delete(fn);\r\n    };\r\n  }\r\n\r\n  private prepareInstance(ctx: ContextArgs<C>): Instance<T> {\r\n    const key = `${this.config?.name ?? \"unknown\"}:${stableHash(ctx)}`;\r\n    if (this.instances.get(key)) return this.instances.get(key)!;\r\n\r\n    let running = true;\r\n\r\n    let resolveClose!: () => void;\r\n    const untilClose = new Promise<void>((r) => (resolveClose = r));\r\n\r\n    const close = () => {\r\n      if (!running) return;\r\n      this.instances.delete(key);\r\n      running = false;\r\n      resolveClose();\r\n    };\r\n\r\n    let resolveRetain!: () => void;\r\n    const untilRetain = new Promise<void>((r) => (resolveRetain = r));\r\n    const retain = async () => {\r\n      resolveRetain();\r\n      await untilClose;\r\n    };\r\n\r\n    let resolveFinish!: () => void;\r\n    const untilFinish = new Promise<void>((r) => (resolveFinish = r));\r\n\r\n    const refs = new Map<\r\n      symbol,\r\n      { notifyEmit: ValueSubscriber<T>; notifyError: ErrorSubscriber }\r\n    >();\r\n\r\n    const waitable = createWaitable<T>({\r\n      equality: this.config?.equality,\r\n      shouldAccept: () => running,\r\n      afterEmit: (next, prev) => {\r\n        refs.forEach((ref) => ref.notifyEmit(next, prev));\r\n        this.globalEmitSubs.forEach((fn) => fn(next, prev, ctx, key));\r\n      },\r\n      afterThrow: (err) => {\r\n        refs.forEach((ref) => ref.notifyError(err));\r\n        this.globalErrorSubs.forEach((fn) => fn(err, ctx, key));\r\n      },\r\n    });\r\n\r\n    const { emit, get } = waitable;\r\n\r\n    Promise.resolve()\r\n      .then(() => this.init({ emit, retain, key }, ctx))\r\n      .catch((err) => {\r\n        waitable.throw(err);\r\n      })\r\n      .then(() => {\r\n        resolveRetain();\r\n        resolveFinish();\r\n      });\r\n\r\n    const instance: Instance<T> = {\r\n      key,\r\n      refs,\r\n      running,\r\n      get,\r\n      close,\r\n      retain,\r\n      untilClose,\r\n      untilRetain,\r\n      untilFinish,\r\n    };\r\n\r\n    this.instances.set(key, instance);\r\n    return instance;\r\n  }\r\n\r\n  private createRef(args: { instance: Instance<T> }) {\r\n    let instance = args.instance;\r\n    const ref = Symbol();\r\n\r\n    const emitSubs = new Set<ValueSubscriber<T>>();\r\n    const errorSubs = new Set<ErrorSubscriber>();\r\n\r\n    const refEntry = {\r\n      notifyEmit: (v: T, prev?: T) => {\r\n        emitSubs.forEach((fn) => fn(v, prev));\r\n      },\r\n      notifyError: (err: unknown) => {\r\n        errorSubs.forEach((fn) => fn(err));\r\n      },\r\n    };\r\n\r\n    instance.refs.set(ref, refEntry);\r\n\r\n    const changeInstance = async (ctx: ContextArgs<C>) => {\r\n      const newInstance = this.prepareInstance(ctx);\r\n      if (newInstance === instance) return;\r\n      await newInstance.untilRetain;\r\n      newInstance.refs.set(ref, refEntry);\r\n      instance.refs.delete(ref);\r\n      instance.close();\r\n      instance = newInstance;\r\n    };\r\n\r\n    return {\r\n      get key() {\r\n        return instance.key;\r\n      },\r\n\r\n      get value() {\r\n        return instance.get();\r\n      },\r\n\r\n      onEmit(fn: ValueSubscriber<T>) {\r\n        emitSubs.add(fn);\r\n        return () => emitSubs.delete(fn);\r\n      },\r\n\r\n      onError(fn: ErrorSubscriber) {\r\n        errorSubs.add(fn);\r\n        return () => errorSubs.delete(fn);\r\n      },\r\n\r\n      reuse(ctx: ContextArgs<C>) {\r\n        changeInstance(ctx);\r\n      },\r\n\r\n      [Symbol.dispose]() {\r\n        instance.refs.delete(ref);\r\n        if (instance.refs.size === 0) {\r\n          instance.close();\r\n        }\r\n      },\r\n    };\r\n  }\r\n}\r\n","type Subscriber<T> = (value: T) => void;\r\n\r\nexport class Action<T> {\r\n  private refs = new Map<symbol, { notify: Subscriber<T> }>();\r\n  private value?: T;\r\n\r\n  get latestValue() {\r\n    return this.value;\r\n  }\r\n\r\n  emit(value: T) {\r\n    for (const { notify } of this.refs.values()) {\r\n      this.value = value;\r\n      notify(value);\r\n    }\r\n  }\r\n\r\n  use() {\r\n    const id = Symbol();\r\n    const subs = new Set<Subscriber<T>>();\r\n\r\n    const entry = {\r\n      notify: (v: T) => {\r\n        subs.forEach((fn) => fn(v));\r\n      },\r\n    };\r\n\r\n    this.refs.set(id, entry);\r\n\r\n    return {\r\n      subscribe(fn: Subscriber<T>) {\r\n        subs.add(fn);\r\n      },\r\n\r\n      [Symbol.dispose]: () => {\r\n        this.refs.delete(id);\r\n      },\r\n    };\r\n  }\r\n}\r\n"],"mappings":"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"}