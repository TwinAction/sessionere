{"version":3,"file":"index.mjs","names":["allowPredicate: (obj: any) => boolean","seen: any[]","parts: string[]","latest: T | undefined","waiting: Array<(value: T) => void>","next: T","emptyInstance: Instance<any>","init: (\r\n      arg: {\r\n        emit: Waitable<T>[\"emit\"];\r\n        retain: Instance<T>[\"retain\"];\r\n        key: string;\r\n      },\r\n      ctx: ContextArgs<C>\r\n    ) => Promise<void> | void","config?: ResourceConfig<T>","resolveClose!: () => void","resolveRetain!: () => void","resolveFinish!: () => void","instance: Instance<T>"],"sources":["../src/lib/stringify.ts","../src/lib/waitable.ts","../src/resource.ts","../src/action.ts"],"sourcesContent":["import { createHash } from \"crypto\";\r\n\r\nclass ReferenceRegistry {\r\n  private refCount = 0;\r\n  private refs = new WeakMap<object, string>();\r\n\r\n  constructor(private allowPredicate: (obj: any) => boolean) {}\r\n\r\n  getId(obj: any): string | undefined {\r\n    if (!this.allowPredicate(obj)) return undefined;\r\n\r\n    if (!this.refs.has(obj)) {\r\n      this.refCount++;\r\n      this.refs.set(obj, `__ref_${this.refCount}__`);\r\n    }\r\n\r\n    return this.refs.get(obj);\r\n  }\r\n}\r\n\r\nconst registry = new ReferenceRegistry((obj) => {\r\n  return (\r\n    typeof obj === \"function\" ||\r\n    (obj && typeof obj === \"object\" && obj.constructor !== Object) ||\r\n    typeof obj === \"symbol\"\r\n  );\r\n});\r\n\r\nfunction stableStringify(data: any): string {\r\n  const seen: any[] = [];\r\n\r\n  function stringifyInternal(node: any): string | undefined {\r\n    if (node && typeof node.toJSON === \"function\") {\r\n      node = node.toJSON();\r\n    }\r\n\r\n    if (registry && node && typeof node === \"object\") {\r\n      const refId = registry.getId(node);\r\n      if (refId) return JSON.stringify(refId);\r\n    }\r\n\r\n    if (typeof node === \"function\") {\r\n      const refId = registry.getId(node);\r\n      if (refId) return JSON.stringify(refId);\r\n      return undefined;\r\n    }\r\n\r\n    if (typeof node === \"bigint\") return `\"${node.toString()}n\"`;\r\n    if (node === undefined) return undefined;\r\n\r\n    if (typeof node !== \"object\" || node === null) {\r\n      if (typeof node === \"number\" && !Number.isFinite(node)) return \"null\";\r\n      return JSON.stringify(node);\r\n    }\r\n\r\n    if (Array.isArray(node)) {\r\n      const out = node.map((v) => stringifyInternal(v) ?? \"null\").join(\",\");\r\n      return `[${out}]`;\r\n    }\r\n\r\n    if (seen.includes(node)) return JSON.stringify(\"__cycle__\");\r\n\r\n    if (node instanceof Date) return `\"${node.toISOString()}\"`;\r\n    if (node instanceof RegExp) return JSON.stringify(node.toString());\r\n\r\n    if (node instanceof Map) {\r\n      const sorted = Array.from(node.entries()).sort((a, b) =>\r\n        String(a[0]).localeCompare(String(b[0]))\r\n      );\r\n      const out = sorted\r\n        .map(([k, v]) => `[${stringifyInternal(k)},${stringifyInternal(v)}]`)\r\n        .join(\",\");\r\n      return `[${out}]`;\r\n    }\r\n\r\n    if (node instanceof Set) {\r\n      const sorted = Array.from(node.values()).sort((a, b) =>\r\n        String(a).localeCompare(String(b))\r\n      );\r\n      const out = sorted.map((v) => stringifyInternal(v)).join(\",\");\r\n      return `[${out}]`;\r\n    }\r\n\r\n    seen.push(node);\r\n    const keys = Object.keys(node).sort();\r\n    const parts: string[] = [];\r\n    for (const key of keys) {\r\n      const val = stringifyInternal(node[key]);\r\n      if (val !== undefined) parts.push(`${JSON.stringify(key)}:${val}`);\r\n    }\r\n    seen.pop();\r\n\r\n    return `{${parts.join(\",\")}}`;\r\n  }\r\n\r\n  return stringifyInternal(data) || \"null\";\r\n}\r\n\r\nexport function stableHash(data: any): string {\r\n  const json = stableStringify(data);\r\n  const hash = createHash(\"sha256\").update(json).digest(\"hex\");\r\n  return hash;\r\n}\r\n","export type Waitable<T> = {\r\n  emit: (value: T | Promise<T> | ((prev?: T) => T | Promise<T>)) => void;\r\n  get: () => Promise<T>;\r\n};\r\n\r\ntype WaitableOptions<T> = {\r\n  shouldAccept?: (next: T, prev?: T) => boolean;\r\n  afterEmit?: (next: T, prev?: T) => void;\r\n  equality?: (a: T, b: T) => boolean;\r\n};\r\n\r\nexport function createWaitable<T>(\r\n  options: WaitableOptions<T> = {}\r\n): Waitable<T> {\r\n  let latest: T | undefined;\r\n  let initialized = false;\r\n  let waiting: Array<(value: T) => void> = [];\r\n\r\n  async function emit(input: T | Promise<T> | ((prev?: T) => T | Promise<T>)) {\r\n    const prev = latest;\r\n\r\n    let next: T;\r\n    try {\r\n      if (typeof input === \"function\") {\r\n        const fn = input as (prev?: T) => T | Promise<T>;\r\n        next = await fn(prev);\r\n      } else {\r\n        next = await input;\r\n      }\r\n    } catch {\r\n      return;\r\n    }\r\n\r\n    const equals = options.equality ?? (() => false);\r\n\r\n    if (initialized && equals(next, prev!)) return;\r\n\r\n    if (options.shouldAccept && !options.shouldAccept(next, prev)) {\r\n      return;\r\n    }\r\n\r\n    latest = next;\r\n    initialized = true;\r\n\r\n    const queued = waiting;\r\n    waiting = [];\r\n    for (const resolve of queued) resolve(next);\r\n\r\n    if (options.afterEmit) {\r\n      queueMicrotask(() => options.afterEmit!(next, prev));\r\n    }\r\n  }\r\n\r\n  function get(): Promise<T> {\r\n    if (initialized) {\r\n      return Promise.resolve(latest as T);\r\n    }\r\n    return new Promise<T>((resolve) => {\r\n      waiting.push(resolve);\r\n    });\r\n  }\r\n\r\n  return { emit, get };\r\n}\r\n","import { stableHash } from \"./lib/stringify\";\r\nimport { createWaitable, Waitable } from \"./lib/waitable\";\r\n\r\nexport type RefLike<T> = {\r\n  readonly key: string;\r\n  readonly value: Promise<T>;\r\n  subscribe: (fn: Subscriber<T>) => () => boolean;\r\n};\r\n\r\ntype GlobalSubscriber<T, C> = (\r\n  value: T,\r\n  prev: T | undefined,\r\n  ctx: ContextArgs<C>,\r\n  key: string\r\n) => void;\r\n\r\ntype ContextArgs<C> = keyof C extends never ? void : C;\r\n\r\ntype Subscriber<T> = (value: T, prev?: T) => void;\r\n\r\ntype ResourceConfig<T> = {\r\n  name?: string;\r\n  equality?: (a: T, b: T) => boolean;\r\n};\r\n\r\ntype Instance<T> = {\r\n  key: string;\r\n  refs: Map<symbol, { notify: Subscriber<T> }>;\r\n  running: boolean;\r\n  get: () => Promise<T>;\r\n  close: () => void;\r\n  retain: () => Promise<void>;\r\n  untilClose: Promise<void>;\r\n  untilRetain: Promise<void>;\r\n  untilFinish: Promise<void>;\r\n};\r\n\r\nconst emptyInstance: Instance<any> = {\r\n  key: \"\",\r\n  refs: new Map(),\r\n  running: false,\r\n  get: async () => {\r\n    throw new Error(\"Called get on empty Resource ref\");\r\n  },\r\n  close: () => {},\r\n  retain: async () => {},\r\n  untilClose: Promise.resolve(),\r\n  untilRetain: Promise.resolve(),\r\n  untilFinish: Promise.resolve(),\r\n};\r\n\r\nexport class Resource<T, C = {}> {\r\n  private globalSubs = new Set<GlobalSubscriber<T, C>>();\r\n  private instances = new Map<string, Instance<T>>();\r\n\r\n  constructor(\r\n    private init: (\r\n      arg: {\r\n        emit: Waitable<T>[\"emit\"];\r\n        retain: Instance<T>[\"retain\"];\r\n        key: string;\r\n      },\r\n      ctx: ContextArgs<C>\r\n    ) => Promise<void> | void,\r\n    private config?: ResourceConfig<T>\r\n  ) {}\r\n\r\n  get name() {\r\n    return this.config?.name;\r\n  }\r\n\r\n  use(ctx: ContextArgs<C>) {\r\n    const instance = this.prepareInstance(ctx);\r\n    return this.createRef({ instance });\r\n  }\r\n\r\n  empty() {\r\n    return this.createRef({ instance: emptyInstance });\r\n  }\r\n\r\n  subscribeAll(fn: GlobalSubscriber<T, C>) {\r\n    this.globalSubs.add(fn);\r\n\r\n    return () => {\r\n      this.globalSubs.delete(fn);\r\n    };\r\n  }\r\n\r\n  private prepareInstance(ctx: ContextArgs<C>): Instance<T> {\r\n    const key = `${this.config?.name ?? \"unknown\"}:${stableHash(ctx)}`;\r\n    if (this.instances.get(key)) return this.instances.get(key)!;\r\n\r\n    let running = true;\r\n\r\n    let resolveClose!: () => void;\r\n    const untilClose = new Promise<void>((r) => (resolveClose = r));\r\n\r\n    const close = () => {\r\n      if (!running) return;\r\n      this.instances.delete(key);\r\n      running = false;\r\n      resolveClose();\r\n    };\r\n\r\n    let resolveRetain!: () => void;\r\n    const untilRetain = new Promise<void>((r) => (resolveRetain = r));\r\n    const retain = async () => {\r\n      resolveRetain();\r\n      await untilClose;\r\n    };\r\n\r\n    let resolveFinish!: () => void;\r\n    const untilFinish = new Promise<void>((r) => (resolveFinish = r));\r\n\r\n    const refs = new Map<symbol, { notify: Subscriber<T> }>();\r\n\r\n    const { emit, get } = createWaitable<T>({\r\n      equality: this.config?.equality,\r\n      shouldAccept: () => running,\r\n      afterEmit: (next, prev) => {\r\n        refs.forEach((ref) => ref.notify(next, prev));\r\n        this.globalSubs.forEach((fn) => fn(next, prev, ctx, key));\r\n      },\r\n    });\r\n\r\n    Promise.resolve(this.init({ emit, retain, key }, ctx)).then(() => {\r\n      resolveRetain();\r\n      resolveFinish();\r\n    });\r\n\r\n    const instance: Instance<T> = {\r\n      key,\r\n      refs,\r\n      running,\r\n      get,\r\n      close,\r\n      retain,\r\n      untilClose,\r\n      untilRetain,\r\n      untilFinish,\r\n    };\r\n\r\n    this.instances.set(key, instance);\r\n    return instance;\r\n  }\r\n\r\n  private createRef(args: { instance: Instance<T> }) {\r\n    let instance = args.instance;\r\n    const ref = Symbol();\r\n\r\n    const subs = new Set<Subscriber<T>>();\r\n\r\n    const refEntry = {\r\n      notify: (v: T) => {\r\n        subs.forEach((fn) => fn(v));\r\n      },\r\n    };\r\n\r\n    instance.refs.set(ref, refEntry);\r\n\r\n    const changeInstance = async (ctx: ContextArgs<C>) => {\r\n      const newInstance = this.prepareInstance(ctx);\r\n      if (newInstance === instance) return;\r\n      await newInstance.untilRetain;\r\n      newInstance.refs.set(ref, refEntry);\r\n      instance.refs.delete(ref);\r\n      instance.close();\r\n      instance = newInstance;\r\n    };\r\n\r\n    return {\r\n      get key() {\r\n        return instance.key;\r\n      },\r\n\r\n      get value() {\r\n        return instance.get();\r\n      },\r\n\r\n      subscribe(fn: Subscriber<T>) {\r\n        subs.add(fn);\r\n        return () => subs.delete(fn);\r\n      },\r\n\r\n      reuse(ctx: ContextArgs<C>) {\r\n        changeInstance(ctx);\r\n      },\r\n\r\n      [Symbol.dispose]() {\r\n        instance.refs.delete(ref);\r\n        if (instance.refs.size === 0) {\r\n          instance.close();\r\n        }\r\n      },\r\n\r\n      async [Symbol.asyncDispose]() {\r\n        instance.refs.delete(ref);\r\n\r\n        if (instance.refs.size === 0) {\r\n          instance.close();\r\n          await instance.untilFinish;\r\n        }\r\n      },\r\n    };\r\n  }\r\n}\r\n","type Subscriber<T> = (value: T) => void;\r\n\r\nexport class Action<T> {\r\n  private refs = new Map<symbol, { notify: Subscriber<T> }>();\r\n  private value?: T;\r\n\r\n  get latestValue() {\r\n    return this.value;\r\n  }\r\n\r\n  emit(value: T) {\r\n    for (const { notify } of this.refs.values()) {\r\n      this.value = value;\r\n      notify(value);\r\n    }\r\n  }\r\n\r\n  use() {\r\n    const id = Symbol();\r\n    const subs = new Set<Subscriber<T>>();\r\n\r\n    const entry = {\r\n      notify: (v: T) => {\r\n        subs.forEach((fn) => fn(v));\r\n      },\r\n    };\r\n\r\n    this.refs.set(id, entry);\r\n\r\n    return {\r\n      subscribe(fn: Subscriber<T>) {\r\n        subs.add(fn);\r\n      },\r\n\r\n      [Symbol.dispose]: () => {\r\n        this.refs.delete(id);\r\n      },\r\n    };\r\n  }\r\n}\r\n"],"mappings":"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"}